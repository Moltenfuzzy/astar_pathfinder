{"version":3,"sources":["AstarPathfinder/Cell/Cell.jsx","Algorithms/Astar.js","AstarPathfinder/AstarPathfinder.jsx","App.js","serviceWorker.js","index.js"],"names":["Cell","props","state","row","col","isVisited","isWall","isStart","isEnd","handleMouseEnter","bind","handleMouseDown","this","setState","console","log","extraClassName","className","id","onMouseEnter","onMouseDown","React","Component","Node","parent","pos","f","g","h","isEqual","current_node","end_node","START_POS","END_POS","AstarPathfinder","grid","numRows","numColumns","array","Array","i","create2DArray","j","getInitialGrid","path","start","end","start_node","open_list","closed_list","push","length","current_index","splice","current","reverse","children","neighbors","node_pos","Math","pow","Astar","animatePath","setTimeout","cell","document","getElementById","style","marginTop","onClick","Visualize","App","Boolean","window","location","hostname","match","ReactDOM","render"],"mappings":"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","file":"static/js/main.aaec0a51.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Cell.css\";\r\n\r\nexport default class Cell extends React.Component {\r\n\r\n\tconstructor(props) {\r\n\t\tsuper(props); \r\n\t\tthis.state = { \r\n\t\t\t\trow: props.row,\r\n\t\t\t\tcol: props.col,\r\n\t\t\t\tisVisited: props.isVisited,\r\n\t\t\t\tisWall: props.isWall,\r\n\t\t\t\tisStart: props.isStart,\r\n\t\t\t\tisEnd: props.isEnd\r\n\t\t}\r\n\t\tthis.handleMouseEnter = this.handleMouseEnter.bind(this); \r\n\t\tthis.handleMouseDown = this.handleMouseDown.bind(this); \r\n\t}\r\n\r\n\t// TODO: ADD CONDITION FOR ISEND SO IT ISNT ISWALL AND ISEND/ISSTART\r\n\r\n\thandleMouseEnter() {\r\n\t\tif(!this.state.isStart)\r\n\t\t\tthis.setState({isWall: true});\r\n\t\t\t// For removing walls \r\n\t\t// if(this.state.isWall)\r\n\t\t// \tthis.setState({isWall: false});\r\n\t}\r\n\r\n\thandleMouseDown() {\r\n\t\tif(!this.state.isStart)\r\n\t\t\tthis.setState({isWall: true});\r\n\t\t\t\r\n\t\tconsole.log(this.state.isWall);\r\n\t\tconsole.log(`Row: ${this.state.row}`);\r\n\t\tconsole.log(`Col: ${this.state.col}`);\r\n\t}\r\n\r\n\trender() {\r\n\t\tconst extraClassName = \r\n\t\tthis.state.isVisited ? 'cell-visited' :\r\n\t\tthis.state.isEnd ? 'cell-end' : \r\n\t\tthis.state.isStart ? 'cell-start': \r\n\t\tthis.state.isWall ? 'cell-wall' : '';\r\n\r\n\t\treturn (\r\n\t\t\t<div \r\n\t\t\t\tclassName={`cell ${extraClassName}`}\r\n\t\t\t\tid = {`cell-${this.state.row}-${this.state.col}`}\r\n\t\t\t\tonMouseEnter={this.handleMouseEnter}\r\n\t\t\t\tonMouseDown={this.handleMouseDown}\r\n\t\t\t>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n","// Pseudocode\r\n\r\n// // A* (star) Pathfinding\r\n// // Initialize both open and closed list\r\n// let the openList equal empty list of nodes\r\n// let the closedList equal empty list of nodes\r\n// // Add the start node\r\n// put the startNode on the openList (leave it's f at zero)\r\n// // Loop until you find the end\r\n// while the openList is not empty\r\n//     // Get the current node\r\n//     let the currentNode equal the node with the least f value\r\n//     remove the currentNode from the openList\r\n//     add the currentNode to the closedList\r\n//     // Found the goal\r\n//     if currentNode is the goal\r\n//         Congratz! You've found the end! Backtrack to get path\r\n//     // Generate children\r\n//     let the children of the currentNode equal the adjacent nodes\r\n    \r\n//     for each child in the children\r\n//         // Child is on the closedList\r\n//         if child is in the closedList\r\n//             continue to beginning of for loop\r\n//         // Create the f, g, and h values\r\n//         child.g = currentNode.g + distance between child and current\r\n//         child.h = distance from child to end\r\n//         child.f = child.g + child.h\r\n//         // Child is already in openList\r\n//         if child.position is in the openList's nodes positions\r\n//             if the child.g is higher than the openList node's g\r\n//                 continue to beginning of for loop\r\n//         // Add the child to the openList\r\n//         add the child to the openList\r\n\r\nclass Node {\r\n\tconstructor(parent = null, pos = null) {\r\n\t\tthis.parent = parent;\r\n\t\tthis.pos = pos;\r\n\t\tthis.f = 0;\r\n\t\tthis.g = 0;\r\n\t\tthis.h = 0;\r\n\t}\r\n}\r\n\r\n// pass in the grid, start and end locations\r\nexport function Astar(grid, start, end) {\r\n\r\n\tlet start_node = new Node(null, start);\r\n\tlet end_node = new Node(null, end); \r\n\r\n\tlet open_list = [];\r\n\tlet closed_list = []; \r\n\r\n\topen_list.push(start_node);\r\n\r\n\twhile(open_list.length > 0) {\r\n\t\tlet current_node = open_list[0];\r\n\t\tlet current_index = 0; \r\n\r\n\t\tfor(let i = 0; i < open_list.length; i++) {\r\n\t\t\t// total cost of node(i) less than current node, \r\n\t\t\t// assign node(i) to current node\r\n\t\t\tif(open_list[i].f < current_node.f) {\r\n\t\t\t\tcurrent_node = open_list[i];\r\n\t\t\t\tcurrent_index = i; \r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// removes current index from open list (index, amount of elements)\r\n\t\topen_list.splice(current_index,1); \r\n\t\tclosed_list.push(current_node); \r\n\r\n\t\t// console.log(isEqual(current_node, end_node));\r\n\r\n\t\t// BUG: Open list is contains too many nodes, closed list is holding 1/10 of open list\r\n\t\tif(isEqual(current_node, end_node)) {\r\n\t\t\tlet path = [];\r\n\t\t\tlet current = current_node;\r\n\r\n\t\t\twhile(current != null) {\r\n\t\t\t\tpath.push(current.pos);\r\n\t\t\t\tcurrent = current.parent;\r\n\t\t\t}\r\n\t\t\treturn path.reverse();\r\n\t\t}\r\n\r\n\t\tlet children = [];\r\n\r\n\t\t// adjacent cells (REFFACTOR INTO A FOR LOOP)\r\n\t\tlet neighbors = [\r\n\t\t\t{row: 0, col: -1}, \r\n\t\t\t{row: 0, col: 1}, \r\n\t\t\t{row: -1, col: 0}, \r\n\t\t\t{row: 1, col: 0}, \r\n\t\t\t{row: -1, col: -1}, \r\n\t\t\t{row: -1, col: 1}, \r\n\t\t\t{row: 1, col: -1}, \r\n\t\t\t{row: 1, col: 1}\r\n\t\t]; \r\n\t\r\n\t\t// BUG: doesnt push any children, so open_list will be 0\r\n\t\t// Generating Children\r\n\t\tfor(let i = 0; i < neighbors.length; i++) {\r\n\t\t\tlet node_pos = {\r\n\t\t\t\trow: current_node.pos.row + neighbors[i].row,\r\n\t\t\t\tcol: current_node.pos.col + neighbors[i].col\r\n\t\t\t};\r\n\r\n\t\t\t// CHECK IF IN RANGE\r\n\t\t\tif(node_pos.row > grid.length - 1 || node_pos.row < 0 || node_pos.col > grid[grid.length-1].length - 1 || node_pos.col < 0)\r\n\t\t\t\tcontinue; \r\n\r\n\t\t\t// Ensuring not wall\r\n\t\t\tif(grid[node_pos.row][node_pos.col].props.isWall)\r\n\t\t\t\tcontinue;\r\n\t\t\r\n\t\t\tchildren.push(new Node(current_node, node_pos)); \r\n\t\t}\r\n\r\n\t\t// Looping through children\r\n\t\tfor(let i = 0; i < children.length; i++) {\r\n\r\n\t\t\tfor(let j = 0; j < closed_list.length; j++) {\r\n\t\t\t\tif(children[i].pos === closed_list[j].pos) {\r\n\t\t\t\t\tcontinue; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tchildren[i].g = current_node.g + 1;\r\n\t\t\t// Pythagoren Theorem => a^2 + b^2 = c^2\r\n\t\t\tchildren[i].h = Math.pow((children[i].pos.row - end_node.pos.row), 2) + Math.pow((children[i].pos.col - end_node.pos.col), 2);\r\n\t\t\tchildren[i].f = children[i].g + children[i].h; \r\n\r\n\t\t\tfor(let j = 0; j < open_list.length; j++) {\r\n\t\t\t\tif(isEqual(children[i], open_list[j]) && children[i].g > open_list[j].g)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\topen_list.push(children[i]); \r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction isEqual(current_node, end_node) {\r\n\treturn (current_node.pos.row === end_node.pos.row) && (current_node.pos.col === end_node.pos.col);\r\n}\r\n\r\n","import React from \"react\";\r\nimport Cell from \"./Cell/Cell\";\r\nimport \"./AstarPathfinder.css\";\r\nimport { Astar } from \"../Algorithms/Astar.js\"\r\n\r\n// TODO: Fix bug with grid thats displaying, each cell doesnt have correct row and col\r\nconst START_POS = {\r\n  row: 1,\r\n  col: 1\r\n}\r\n\r\nconst END_POS = {\r\n  row: 18,\r\n  col: 28\r\n}\r\n\r\nexport default class AstarPathfinder extends React.Component {\r\n\r\n  // dont put jsx in state\r\n  // call the function directly inside render, and render that\r\n  // store the data that you use to render JSX in state, and map over that state data inside render\r\n  // Also this can be turned into a function\r\n\r\n  constructor() { \r\n    super(); \r\n    this.grid = getInitialGrid();\r\n  }\r\n\r\n  Visualize() {\r\n    // how do i get the updated grid ??\r\n    const grid = this.grid; \r\n    const path = Astar(grid, START_POS, END_POS);\r\n    this.animatePath(path);\r\n    console.log(path); \r\n  } \r\n\r\n  animatePath(path) {\r\n    for (let i = 0; i < path.length; i++) {\r\n      setTimeout(() => {\r\n        const cell = path[i];\r\n        document.getElementById(`cell-${cell.row}-${cell.col}`).className =\r\n          'cell cell-path';\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <button style={{marginTop: \"50px\"}}onClick={() => this.Visualize()}>\r\n          Visualize \r\n        </button>\r\n        <div className=\"grid\">\r\n          {this.grid}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// REMOVE MAGIC NUMBERS\r\nfunction getInitialGrid() {\r\n  let grid = create2DArray(20,30);\r\n\r\n  for(let i = 0; i < 20; i++) {\r\n    for(let j = 0; j < 30; j++) {\r\n      // TODO: CHANGE THESE TO CONSTANTS OR ALLOW USER TO INPUT LOCATION\r\n      if(i === START_POS.row && j === START_POS.col) {\r\n        // This is why we need to pass props into child components\r\n        // If we don't then it wouldnt define these properties im passing in the component\r\n        grid[i][j] = <Cell row={i} col={j} isWall={false} isStart={true} isEnd={false}/>;\r\n      }\r\n      else if(i === END_POS.row && j === END_POS.col) {\r\n        grid[i][j] = <Cell row={i} col={j} isWall={false} isStart={false} isEnd={true}/>;\r\n      }\r\n      // else if(i == 15 && j == 15) {\r\n      //   grid[i][j] = <Cell row={i} col={j} isWall={true} isStart={false} isEnd={false}/>;\r\n      // }\r\n      else {\r\n        grid[i][j] = <Cell row={i} col={j} isWall={false} isStart={false} isEnd={false}/>; \r\n      }\r\n    }\r\n  }\r\n\r\n  return grid; \r\n}\r\n\r\nfunction create2DArray(numRows, numColumns) {\r\n  let array = new Array(numRows); \r\n \r\n  for(let i = 0; i < numRows; i++) {\r\n    array[i] = new Array(numColumns); \r\n  }\r\n \r\n  return array; \r\n}\r\n","import React from 'react';\nimport './App.css';\nimport AstarPathfinder from './AstarPathfinder/AstarPathfinder'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <AstarPathfinder />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n"],"sourceRoot":""}